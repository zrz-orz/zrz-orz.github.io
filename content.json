{"meta":{"title":"zrz_orz's Blog","subtitle":null,"description":null,"author":"zrz_orz","url":"https://zrz-orz.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-09-21T06:55:52.000Z","updated":"2019-09-21T06:55:52.494Z","comments":true,"path":"categories/index.html","permalink":"https://zrz-orz.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-21T06:55:31.000Z","updated":"2019-09-21T06:55:31.901Z","comments":true,"path":"tags/index.html","permalink":"https://zrz-orz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2-Sat 学习 ","slug":"2-Sat-学习","date":"2019-09-29T19:42:35.000Z","updated":"2019-09-29T20:04:55.104Z","comments":true,"path":"2019/09/30/2-Sat-学习/","link":"","permalink":"https://zrz-orz.github.io/2019/09/30/2-Sat-学习/","excerpt":"2-sat 众所周知是适应性问题。是 k-sat 问题的分支，但是 $k &gt;= 3$ 时他是 NP 问题2-sat 主要用来处理形如: 每种元素有两种状态, 选 $A$ 状态必须选 $B$ 状态或 选 $A$ 状态不能选 $B$ 状态等限制的问题常用的方法是 $Dfs$ 或 $SCC$.先对于每个元素拆成两个点代表这个元素的两种状态，再对于限制连边","text":"2-sat 众所周知是适应性问题。是 k-sat 问题的分支，但是 $k &gt;= 3$ 时他是 NP 问题2-sat 主要用来处理形如: 每种元素有两种状态, 选 $A$ 状态必须选 $B$ 状态或 选 $A$ 状态不能选 $B$ 状态等限制的问题常用的方法是 $Dfs$ 或 $SCC$.先对于每个元素拆成两个点代表这个元素的两种状态，再对于限制连边 边 $(u, v)$ 的含义为 $u$ 的状态与 $v$ 相同 那么对于一个强连通分量，里面的点一定是要一起选的，而一个元素只有一种状态那么对于同一个元素的两个点不可能属于一个强连通分量 这就判断了可行性 如何输出解?? 可以 $Dfs$ 不过一种可行的方案是选取每个元素强连通分量编号较小的一个。 不会证，好像和拓扑序的反序有关 例题: Luogu 2-SAT 问题 有 $N$ 个布尔变量$x_1$, $M$ 个需要满足的条件，每个条件的形式都是&quot;$x_i$ $true/false$ 或 $x_j$ $true/false$&quot;。比如&quot;$x_1$为真或$x_3$为假&quot;,&quot;$x_7$为假或$x_2$为假&quot;。 $2-SAT$ 问题的目标是给每个变量赋值使得所有条件得到满足。 显然的建图方式 当状态 $A$ 不成立时,状态 $B$ 一定成立 反过来也连一次 代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define rep(i, a, b) for(int i = a; i &lt;= b; ++i)#define ll long longusing namespace std;#define N 2000005int n, m, cnt, id, tot;int fir[N], nx[N &lt;&lt; 1], to[N &lt;&lt; 1];int dfn[N], low[N], scc[N];stack&lt;int&gt; st;bool vis[N];inline void add(int _, int __) &#123; nx[++cnt] = fir[_]; fir[_] = cnt; to[cnt] = __;&#125;void tarjan(int x) &#123; dfn[x] = low[x] = ++id; st.push(x); vis[x] = 1; for (int i = fir[x]; i; i = nx[i]) &#123; int v = to[i]; if (!dfn[v]) &#123; tarjan(v); low[x] = min(low[x], low[v]); &#125; else if (vis[v]) low[x] = min(low[x], dfn[v]); &#125; if (low[x] == dfn[x]) &#123; int tmp; ++tot; do &#123; tmp = st.top(); st.pop(); vis[tmp] = 0; scc[tmp] = tot; &#125; while(tmp != x); &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; int x, y, a, b; rep (i, 1, m) &#123; cin &gt;&gt; x &gt;&gt; a &gt;&gt; y &gt;&gt; b; add(x + (a ^ 1) * n, y + b * n); add(y + (b ^ 1) * n, x + a * n); &#125; rep (i, 1, n * 2) if (!dfn[i]) tarjan(i); rep (i, 1, n) &#123; if (scc[i] == scc[i + n]) &#123; puts(\"IMPOSSIBLE\"); return 0; &#125; &#125; puts (\"POSSIBLE\"); rep (i, 1, n) &#123; if (scc[i] &gt; scc[i + n]) printf(\"1 \"); else printf(\"0 \"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"图论","slug":"图论","permalink":"https://zrz-orz.github.io/tags/图论/"}]},{"title":"「Test20190927」Poker  ","slug":"「Test20190927」Poker","date":"2019-09-27T06:13:46.000Z","updated":"2019-09-27T06:31:37.455Z","comments":true,"path":"2019/09/27/「Test20190927」Poker/","link":"","permalink":"https://zrz-orz.github.io/2019/09/27/「Test20190927」Poker/","excerpt":"发现一件只有相同的数字才会对答案有影响。打表!!! 总数\\相同的个数 2 3 4 5 6 4 4 12 24 6 72 216 432 720 8 2880 17280 ... ... ... 上面这个表是与答案的偏差值$$ 4 = 24 * \\frac{1}{6} , 12 = 24 * \\frac{3}{6} , 24 = 24 * \\frac{6}{6} $$","text":"发现一件只有相同的数字才会对答案有影响。打表!!! 总数\\相同的个数 2 3 4 5 6 4 4 12 24 6 72 216 432 720 8 2880 17280 ... ... ... 上面这个表是与答案的偏差值$$ 4 = 24 * \\frac{1}{6} , 12 = 24 * \\frac{3}{6} , 24 = 24 * \\frac{6}{6} $$ $$ 72 = 720 * \\frac{1}{15} , 216 = 720 * \\frac{3}{15} , 432 = 720 * \\frac{6}{15} , 720 = 720 * \\frac{15}{15} $$ 好像看出规律了 233333333 淦！！ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define MOD 1000000007#define N 100005int n;int a[N], b[N], x[N];ll fac[N] = &#123;1&#125;, f[N];inline ll ksm(ll x, int p) &#123; ll res = 1; for (; p; p &gt;&gt;= 1, x = x * x % MOD) if (p &amp; 1) res = res * x % MOD; return res;&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen(\"poker.in\", \"r\", stdin); freopen(\"poker.out\", \"w\", stdout);#endif read(n); rep (i, 1, n) read(a[i]), b[i] = a[i]; if (n == 2) &#123; if (a[1] == a[2]) &#123; printf(\"%d %d\\n\", 0, 2); return 0; &#125; else &#123; printf(\"1 1\\n\"); return 0; &#125; &#125; std::sort(b + 1, b + n + 1); int len = std::unique(b + 1, b + n + 1) - b - 1; rep (i, 1, n) a[i] = std::lower_bound(b + 1, b + len + 1, a[i]) - b; rep (i, 1, n) &#123; fac[i] = fac[i - 1] * i % MOD; &#125; ll A = fac[n] * n % MOD * ksm(4, MOD - 2), B = A; memset(b, 0, sizeof b); rep (i, 1, n) ++b[a[i]]; f[2] = 4; ll tmp1 = 3, tmp2 = 6; for (int i = 6; i &lt;= n; i += 2) &#123; f[2] = f[2] * tmp1 % MOD * tmp2 % MOD; tmp1 += 2, tmp2 += 2; tmp1 %= MOD, tmp2 %= MOD; &#125; rep (i, 3, n) &#123; f[i] = f[2] * (i * (i - 1) % MOD * ksm(2, MOD - 2) % MOD) % MOD; &#125; rep (i, 1, len) &#123; if (b[i] &gt;= 2) &#123; A -= f[b[i]]; B += f[b[i]]; A = (A + MOD) % MOD; B %= MOD; &#125; &#125; printf(\"%lld %lld\\n\", A, B); return 0;&#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| _________________________________________ &lt; poker.cpp is created by zrz who is weak &gt; ----------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"找规律","slug":"找规律","permalink":"https://zrz-orz.github.io/tags/找规律/"}]},{"title":"「SDOI2008」郁闷的小J  ","slug":"「SDOI2008」郁闷的小J","date":"2019-09-24T13:31:15.000Z","updated":"2019-09-24T23:56:29.007Z","comments":true,"path":"2019/09/24/「SDOI2008」郁闷的小J/","link":"","permalink":"https://zrz-orz.github.io/2019/09/24/「SDOI2008」郁闷的小J/","excerpt":"","text":"这题可以分块，可以带修主席树，可以STL一套 不过 Luogu 的题解里面好像没有带修莫队的。 难道就我觉得这是模板题吗。。 上来就打莫队。。 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 200005int n, m, tot, Cnt;int a[N], b[N], pos[N], ans[N];class Query &#123;public: int l, r, val, id, last, t;&#125; q[N], o[N];int cnt[N &lt;&lt; 1];std::map&lt;int, int&gt; mp;bool cmp(Query A, Query B) &#123; if (pos[A.l] == pos[B.l]) &#123; if (pos[A.r] == pos[B.r]) return A.t &lt; B.t; else return pos[A.r] &lt; pos[B.r]; &#125; return pos[A.l] &lt; pos[B.l];&#125;int main() &#123;#ifndef ONLINE_JUDGE freopen(\"2464.in\", \"r\", stdin); freopen(\"2464.out\", \"w\", stdout);#endif read(n), read(m); rep (i, 1, n) read(a[i]), b[++tot] = a[i]; char opt[4]; int O = 0, Q = 0; rep (i, 1, m) &#123; scanf (\"%s\", opt); if (opt[0] == 'Q') &#123; ++Q; read(q[Q].l), read(q[Q].r), read(q[Q].val); b[++tot] = q[Q].val; q[Q].id = Q, q[Q].t = O; &#125; else &#123; ++O; read(o[O].l), read(o[O].val); b[++tot] = o[O].val; o[O].t = O; &#125; &#125; std::sort(b + 1, b + tot + 1); rep (i, 1, tot) &#123; if (mp[b[i]]) continue; mp[b[i]] = ++Cnt; &#125; rep (i, 1, n) a[i] = mp[a[i]]; rep (i, 1, Q) q[i].val = mp[q[i].val]; rep (i, 1, O) o[i].val = mp[o[i].val]; tot = 1; int siz = pow(n, 0.6666667); rep (i, 1, n) &#123; pos[i] = tot; if (i % siz == 0) ++tot; &#125; std::sort(q + 1, q + Q + 1, cmp); rep (i, 1, n) b[i] = a[i]; rep (i, 1, O) &#123; o[i].last = b[o[i].l]; b[o[i].l] = o[i].val; &#125; int L = 1, R = 0, K = 0; rep (i, 1, Q) &#123; while (K &lt; q[i].t) &#123; ++K; if (o[K].l &gt;= L &amp;&amp; o[K].l &lt;= R) --cnt[a[o[K].l]], ++cnt[o[K].val]; a[o[K].l] = o[K].val; &#125; while (K &gt; q[i].t) &#123; if (o[K].l &gt;= L &amp;&amp; o[K].l &lt;= R) --cnt[a[o[K].l]], ++cnt[o[K].last]; a[o[K].l] = o[K].last; --K; &#125; while (R &lt; q[i].r) &#123; ++R; cnt[a[R]]++; &#125; while (L &gt; q[i].l) &#123; --L; cnt[a[L]]++; &#125; while (R &gt; q[i].r) &#123; cnt[a[R]]--; --R; &#125; while (L &lt; q[i].l) &#123; cnt[a[L]]--; ++L; &#125; ans[q[i].id] = cnt[q[i].val]; &#125; rep (i, 1, Q) printf(\"%d\\n\", ans[i]); return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 2464.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zrz-orz.github.io/tags/数据结构/"},{"name":"莫队","slug":"莫队","permalink":"https://zrz-orz.github.io/tags/莫队/"}]},{"title":"「COCI 2009」极地旅行社 ","slug":"「COCI-2009」极地旅行社","date":"2019-09-23T12:41:40.000Z","updated":"2019-09-23T12:43:06.929Z","comments":true,"path":"2019/09/23/「COCI-2009」极地旅行社/","link":"","permalink":"https://zrz-orz.github.io/2019/09/23/「COCI-2009」极地旅行社/","excerpt":"","text":"LCT模板题，本来拿来练手的结果调了好久 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 30005#define F(x) tree[x].fa#define S(fa, son) tree[fa].ch[son]#define P(fa, son) (tree[fa].ch[1] == son)#define ls(x) tree[x].ch[0]#define rs(x) tree[x].ch[1]int n, q;class Node &#123;public: int val, fa, ch[2], rev, sum;&#125; tree[N];inline void pushup(int x) &#123; tree[x].sum = tree[ls(x)].sum + tree[rs(x)].sum + tree[x].val; &#125;inline bool noroot(int x) &#123; return tree[F(x)].ch[0] == x || tree[F(x)].ch[1] == x; &#125;inline void reverse(int x) &#123; std::swap(ls(x), rs(x)); tree[x].rev ^= 1;&#125;inline void pushdown(int x) &#123; if (tree[x].rev) &#123; if (ls(x)) reverse(ls(x)); if (rs(x)) reverse(rs(x)); tree[x].rev = 0; &#125;&#125;void rotate(int x) &#123; int y = F(x), z = F(y), p = P(y, x), q = P(z, y), a = S(x, p ^ 1); if (noroot(y)) S(z, q) = x; S(x, p ^ 1) = y, S(y, p) = a; if (a) F(a) = y; F(y) = x, F(x) = z; pushup(y), pushup(x);&#125;void pushall(int x) &#123; if (noroot(x)) pushall(F(x)); pushdown(x);&#125;void Splay(int x) &#123; pushall(x); while (noroot(x)) &#123; int y = F(x), z = F(y); if (noroot(y)) rotate(P(z, y) ^ P(y, x) ? x : y); rotate(x); &#125; pushup(x);&#125;inline void access(int x) &#123; int last = 0; while (x) &#123; Splay(x); S(x, 1) = last; pushup(x); last = x; x = F(x); &#125;&#125;inline void makeroot(int x) &#123; access(x), Splay(x), reverse(x);&#125;inline int findroot(int x) &#123; access(x), Splay(x); while (ls(x)) &#123; pushdown(x); x = ls(x); &#125; Splay(x); return x;&#125;inline bool link(int x, int y) &#123; makeroot(x); if (findroot(y) == x) return false; F(x) = y; return true;&#125;inline void split(int x, int y) &#123; makeroot(x), access(y); Splay(y);&#125;int main() &#123; read(n); rep (i, 1, n) read(tree[i].val); int x, y; char opt[10]; read(q); while (q--) &#123; scanf (\"%s\", opt); switch(opt[0]) &#123; case 'b' : read(x), read(y); if (link(x, y)) puts(\"yes\"); else puts(\"no\"); break; case 'e' : read(x), read(y); if (findroot(y) != findroot(x)) &#123; puts(\"impossible\"); break; &#125; split(x, y); printf(\"%d\\n\", tree[y].sum); break; case 'p' : read(x), read(y); Splay(x); tree[x].val = y; pushup(x); break; &#125; &#125; return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 4312.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zrz-orz.github.io/tags/数据结构/"}]},{"title":"「Test」Sort ","slug":"「Test」Sort","date":"2019-09-23T08:22:07.000Z","updated":"2019-09-23T08:26:30.311Z","comments":true,"path":"2019/09/23/「Test」Sort/","link":"","permalink":"https://zrz-orz.github.io/2019/09/23/「Test」Sort/","excerpt":"","text":"我太菜了。。 这都不会。。 首先可以直接知道他进行了几次完整的操作。 考虑剩下的位置 按权值从大到小考虑。 一个数只会被他前面的大的数交换 那么一个数要么在第一个空位上，要么在原来的位置上。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 1000005int n;ll cnt;int a[N], fa[N];int b[N], Pos[N];int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125;int main() &#123; freopen (\"sort.in\", \"r\", stdin); freopen (\"sort.out\", \"w\", stdout); read(n), read(cnt); rep (i, 1, n) read(a[i]), Pos[a[i]] = i; int pos = n; rep (i, 1, n) &#123; if (cnt &lt; n - i) &#123; pos = i - 1; break; &#125; cnt -= n - i; &#125; rep (i, 1, pos) &#123; b[i] = i; &#125; int tot = pos; per (i, n, pos + 1) &#123; if (Pos[i] &lt;= tot) &#123; while (b[tot]) ++tot; b[tot] = i; &#125; else &#123; b[Pos[i]] = i; &#125; &#125; rep (i, pos + 1, n) &#123; if (!cnt) break; rep (j, i + 1, n) &#123; if (b[i] &gt; b[j]) std::swap(b[i], b[j]); --cnt; if (!cnt) break; &#125; if (!cnt) break; &#125; rep (i, 1, n) printf(\"%d \", b[i]); puts(\"\"); return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; sort.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://zrz-orz.github.io/tags/贪心/"}]},{"title":"「Luogu 5029」 T'ill It's Over","slug":"「Luogu-5029」-T-ill-It-s-Over","date":"2019-09-23T06:08:35.000Z","updated":"2019-09-23T06:19:39.854Z","comments":true,"path":"2019/09/23/「Luogu-5029」-T-ill-It-s-Over/","link":"","permalink":"https://zrz-orz.github.io/2019/09/23/「Luogu-5029」-T-ill-It-s-Over/","excerpt":"","text":"对于每一种长度开一个点，那么每种操作分别建边跑网络流。 因为有区间加边所以要线段树优化建边。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 3000005#define M 300005int n, m, k, tot, cnt = 1;int fir[N], nx[N &lt;&lt; 1], to[N &lt;&lt; 1], w[N &lt;&lt; 1], cur[N], dep[N];int tree[M &lt;&lt; 2][2];inline void add(int _, int __, int ___) &#123; nx[++cnt] = fir[_]; fir[_] = cnt; to[cnt] = __; w[cnt] = ___;&#125;void build(int l, int r, int x, int type) &#123; if (l == r) &#123; tree[x][type] = l; return; &#125; tree[x][type] = ++tot; int mid = l + r &gt;&gt; 1; build(l, mid, x &lt;&lt; 1, type); build(mid + 1, r, x &lt;&lt; 1 | 1, type); if (type == 0) &#123; add(tree[x &lt;&lt; 1][type], tree[x][type], INT_MAX); add(tree[x][type], tree[x &lt;&lt; 1][type], 0); add(tree[x &lt;&lt; 1 | 1][type], tree[x][type], INT_MAX); add(tree[x][type], tree[x &lt;&lt; 1 | 1][type], 0); &#125; else &#123; add(tree[x][type], tree[x &lt;&lt; 1][type], INT_MAX); add(tree[x &lt;&lt; 1][type], tree[x][type], 0); add(tree[x][type], tree[x &lt;&lt; 1 | 1][type], INT_MAX); add(tree[x &lt;&lt; 1 | 1][type], tree[x][type], 0); &#125;&#125;void addTree(int l, int r, int la, int ra, int p, int val, int x, int type) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) &#123; if (type == 0) &#123; add(tree[x][type], p, val); add(p, tree[x][type], 0); &#125; else &#123; add(p, tree[x][type], val); add(tree[x][type], p, 0); &#125; return; &#125; int mid = l + r &gt;&gt; 1; if (la &lt;= mid) addTree(l, mid, la, ra, p, val, x &lt;&lt; 1, type); if (ra &gt; mid) addTree(mid + 1, r, la, ra, p, val, x &lt;&lt; 1 | 1, type);&#125;void addEdge(int l, int r, int L, int R, int val) &#123; int p = ++tot; addTree(1, k, l, r, p, val, 1, 0); addTree(1, k, L, R, p, val, 1, 1);&#125;std::queue&lt;int&gt; q;inline bool Bfs(int s, int t) &#123; memset(dep, 0, sizeof dep); q.push(s); dep[s] = 1; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = fir[x]; i; i = nx[i]) &#123; int v = to[i]; if (!dep[v] &amp;&amp; w[i] &gt; 0) &#123; dep[v] = dep[x] + 1; q.push(v); &#125; &#125; &#125; return (dep[t] &gt; 0);&#125;int Dfs(int x, int t, int Flow) &#123; if (x == t) return Flow; for (int &amp;i = cur[x]; i; i = nx[i]) &#123; int v = to[i]; if (dep[v] == dep[x] + 1 &amp;&amp; w[i] &gt; 0) &#123; int nowFlow = Dfs(v, t, min(Flow, w[i])); if (!nowFlow) continue; w[i] -= nowFlow; w[i ^ 1] += nowFlow; return nowFlow; &#125; &#125; return 0;&#125;inline int Dinic(int s, int t) &#123; int sumFlow = 0, d; while (Bfs(s, t)) &#123; memcpy(cur, fir, sizeof fir); while (d = Dfs(s, t, INT_MAX)) &#123; sumFlow += d; &#125; &#125; return sumFlow;&#125;int main() &#123; read(n), read(m), read(k); tot = k; build(1, k, 1, 0); build(1, k, 1, 1); int opt, l, r, L, R, val; rep (i, 1, m) &#123; read(opt), read(val); if (opt == 1) &#123; read(l), read(r); add(l, r, val), add(r, l, 0); &#125; if (opt == 2) &#123; read(l), read(r), read(L); addEdge(l, r, L, L, val); addEdge(L, L, l, r, 0); &#125; if (opt == 3) &#123; read(l), read(L), read(R); addEdge(l, l, L, R, val); addEdge(L, R, l, l, 0); &#125; if (opt == 4) &#123; read(l), read(r), read(L), read(R); addEdge(l, r, L, R, val); addEdge(L, R, l, r, 0); &#125; &#125; add(0, 1, n); add(1, 0, n); printf(\"%d\\n\", Dinic(0, k)); return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 5029.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zrz-orz.github.io/tags/数据结构/"},{"name":"网络流","slug":"网络流","permalink":"https://zrz-orz.github.io/tags/网络流/"}]},{"title":"「CERC」Bricks","slug":"「CERC」Bricks","date":"2019-09-22T12:37:05.000Z","updated":"2019-09-23T06:16:46.391Z","comments":true,"path":"2019/09/22/「CERC」Bricks/","link":"","permalink":"https://zrz-orz.github.io/2019/09/22/「CERC」Bricks/","excerpt":"","text":"首先发现一个性质。 分割的比例为黑白砖块总数的比 那么能分就分。 要判只有一种颜色的情况 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 100005int T;int n, m;char s[3];ll all[2];class Node &#123;public: int val, type;&#125; a[N];int main() &#123; read(T); while (T--) &#123; read(n); all[0] = all[1] = 0; rep (i, 1, n) &#123; read(a[i].val); scanf (\"%s\", s); if (s[0] == 'W') a[i].type = 1; else a[i].type = 0; all[a[i].type] += a[i].val; &#125; if (!all[0] || !all[1]) &#123; printf(\"%lld\\n\", all[0] + all[1]); continue; &#125; ll tot[2], ans = 0; tot[0] = tot[1] = 0; rep (i, 1, n) &#123; if (!tot[0] &amp;&amp; !tot[1]) tot[a[i].type] = a[i].val; else &#123; if (a[i].type == 1) &#123; if (tot[0] * all[1] % all[0]) &#123; tot[1] += a[i].val; continue; &#125; ll need = tot[0] * all[1] / all[0]; if (need == 0) &#123; tot[1] += a[i].val; continue; &#125; if (need &lt;= a[i].val + tot[1] &amp;&amp; need - tot[1] &gt;= 0) &#123; ll tmp = tot[1] + a[i].val - need; tot[0] = tot[1] = 0; tot[1] = tmp; ++ans; &#125; else &#123; tot[1] += a[i].val; continue; &#125; &#125; else &#123; if (tot[1] * all[0] % all[1]) &#123; tot[0] += a[i].val; continue; &#125; ll need = tot[1] * all[0] / all[1]; if (need == 0) &#123; tot[0] += a[i].val; continue; &#125; if (need &lt;= a[i].val + tot[0] &amp;&amp; need - tot[0] &gt;= 0) &#123; ll tmp = tot[0] + a[i].val - need; tot[0] = tot[1] = 0; tot[0] = tmp; ++ans; &#125; else &#123; tot[0] += a[i].val; continue; &#125; &#125; &#125; &#125; printf(\"%lld\\n\", ans); &#125; return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 4763.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"贪心","slug":"贪心","permalink":"https://zrz-orz.github.io/tags/贪心/"}]},{"title":"「Test」全连","slug":"「Test」全连","date":"2019-09-22T11:46:07.000Z","updated":"2019-09-23T06:16:26.651Z","comments":true,"path":"2019/09/22/「Test」全连/","link":"","permalink":"https://zrz-orz.github.io/2019/09/22/「Test」全连/","excerpt":"","text":"考试的时候想到了线段树，但时间不够就随手打了打，超时了 晚上去厕所的时候想了一下，发现自己傻逼了。。 在维护左端点的时候用堆维护一下就好了。 我居然傻乎乎的写了考试的时候那种 ZZ 做法。。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;long long, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 1000005int n;ll t[N], a[N];ll f[N &lt;&lt; 1];class SegmentTree &#123;public: PI tree[N &lt;&lt; 2]; void pushup(int x) &#123; if (tree[x &lt;&lt; 1].first &gt; tree[x &lt;&lt; 1 | 1].first) tree[x] = tree[x &lt;&lt; 1]; else tree[x] = tree[x &lt;&lt; 1 | 1]; &#125; void modify(int l, int r, int pos, ll val, int x) &#123; if (l == r) return tree[x].first = val, tree[x].second = l, void(); reg int mid = l + r &gt;&gt; 1; if (pos &lt;= mid) modify(l, mid, pos, val, x &lt;&lt; 1); else modify(mid + 1, r, pos, val, x &lt;&lt; 1 | 1); pushup(x); &#125; PI query(int l, int r, int la, int ra, int x) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) return tree[x]; int mid = l + r &gt;&gt; 1; PI res; res.first = -LLONG_MAX; res.second = 0; if (la &lt;= mid) res = query(l, mid, la, ra, x &lt;&lt; 1); if (ra &gt; mid) &#123; PI tmp = query(mid + 1, r, la, ra, x &lt;&lt; 1 | 1); if (tmp.first &gt;= res.first) res = tmp; &#125; return res; &#125; void build(int l, int r, int x) &#123; if (l == r) return tree[x].first = -LLONG_MAX, tree[x].second = 0, void(); reg int mid = l + r &gt;&gt; 1; build(l, mid, x &lt;&lt; 1); build(mid + 1, r, x &lt;&lt; 1 | 1); pushup(x); &#125;&#125; seg;int tot; int tf[N];std::priority_queue&lt;PI&gt; q; int main() &#123; freopen (\"fc.in\", \"r\", stdin); freopen (\"fc.out\", \"w\", stdout); read(n); seg.build(1, n, 1); rep (i, 1, n) read(t[i]); rep (i, 1, n) read(a[i]), a[i] = a[i] * t[i]; per (i, n, 1) &#123; while (!q.empty() &amp;&amp; q.top().first &gt;= i) &#123; reg PI tmp = q.top(); q.pop(); seg.modify(1, n, tmp.second, f[tmp.second], 1); &#125; reg int pos = i + t[i]; if (pos &gt; n) f[i] = a[i]; else &#123; reg PI tmp = seg.query(1, n, pos, n, 1); if (tmp.first == -LLONG_MAX) &#123; f[i] = a[i]; q.push(mk(i - t[i], i)); continue; &#125; reg int id = tmp.second; if (id - t[id] &lt; i) &#123; tf[++tot] = id; seg.modify(1, n, id, -LLONG_MAX, 1); &#125; else &#123; f[i] = f[id] + a[i]; &#125; &#125; q.push(mk(i - t[i], i)); &#125; ll ans = 0; rep (i, 1, n) &#123; ans = max(ans, f[i]); &#125; printf(\"%lld\\n\", ans); return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ______________________________________ &lt; fc.cpp is created by zrz who is weak &gt; -------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zrz-orz.github.io/tags/数据结构/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zrz-orz.github.io/tags/动态规划/"}]},{"title":"「Luogu 2787」 语文1(chin1)-理理思维","slug":"「Luogu-2787」-语文1-chin1-理理思维","date":"2019-09-22T04:00:42.000Z","updated":"2019-09-23T06:16:35.878Z","comments":true,"path":"2019/09/22/「Luogu-2787」-语文1-chin1-理理思维/","link":"","permalink":"https://zrz-orz.github.io/2019/09/22/「Luogu-2787」-语文1-chin1-理理思维/","excerpt":"","text":"听说这是珂朵莉树的板子，但是我不会 开 $26$ 棵线段树，线段树要支持区间赋值，区间求和。 之后的就暴力更新。 毒瘤题面，在最后说大小写不敏感。。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 50005int n, m;char s[N];class SegmentTree &#123;public: int tree[N &lt;&lt; 2], tag[N &lt;&lt; 2]; SegmentTree() &#123; memset(tag, -1, sizeof tag); &#125; void pushup(int x) &#123; tree[x] = tree[x &lt;&lt; 1] + tree[x &lt;&lt; 1 | 1]; &#125; void pushdown(int x, int l, int r) &#123; if (tag[x] != -1) &#123; int mid = l + r &gt;&gt; 1; tree[x &lt;&lt; 1] = tag[x] * (mid - l + 1), tree[x &lt;&lt; 1 | 1] = tag[x] * (r - mid); tag[x &lt;&lt; 1] = tag[x], tag[x &lt;&lt; 1 | 1] = tag[x]; tag[x] = -1; &#125; &#125; void modify(int l, int r, int la, int ra, int x, int val) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) &#123; tree[x] = val * (r - l + 1); tag[x] = val; return; &#125; reg int mid = l + r &gt;&gt; 1; pushdown(x, l, r); if (la &lt;= mid) modify(l, mid, la, ra, x &lt;&lt; 1, val); if (ra &gt; mid) modify(mid + 1, r, la, ra, x &lt;&lt; 1 | 1, val); pushup(x); &#125; int query(int l, int r, int la, int ra, int x) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) return tree[x]; reg int mid = l + r &gt;&gt; 1; int res = 0; pushdown(x, l, r); if (la &lt;= mid) res += query(l, mid, la, ra, x &lt;&lt; 1); if (ra &gt; mid) res += query(mid + 1, r, la, ra, x &lt;&lt; 1 | 1); return res; &#125; &#125; seg[26];inline void Modify(int l, int r, int id) &#123; rep (i, 0, 25) &#123; seg[i].modify(1, n, l, r, 1, 0); &#125; seg[id].modify(1, n, l, r, 1, 1);&#125;inline void Sort(int l, int r) &#123; int tmp[30]; memset(tmp, 0, sizeof tmp); rep (i, 0, 25) tmp[i] = seg[i].query(1, n, l, r, 1); rep (i, 0, 25) seg[i].modify(1, n, l, r, 1, 0); int pos = l; rep (i, 0, 25) &#123; int nx = pos + tmp[i] - 1; if (nx &lt; pos) continue; seg[i].modify(1, n, pos, nx, 1, 1); pos = nx + 1; &#125;&#125;int main() &#123; read(n), read(m); scanf (\"%s\", s + 1); rep (i, 1, n) &#123; if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') s[i] = s[i] - 'a' + 'A'; seg[s[i] - 'A'].modify(1, n, i, i, 1, 1); &#125; int opt, l, r; char str[4]; while(m--) &#123; read(opt), read(l), read(r); switch(opt) &#123; case 1 : scanf (\"%s\", str); if (str[0] &gt;= 'a' &amp;&amp; str[0] &lt;= 'z') str[0] = str[0] - 'a' + 'A'; printf(\"%d\\n\", seg[str[0] - 'A'].query(1, n, l, r, 1)); break; case 2 : scanf (\"%s\", str); if (str[0] &gt;= 'a' &amp;&amp; str[0] &lt;= 'z') str[0] = str[0] - 'a' + 'A'; Modify(l, r, str[0] - 'A'); break; case 3 : Sort(l, r); break; &#125; &#125; return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 2787.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zrz-orz.github.io/tags/数据结构/"},{"name":"字符串","slug":"字符串","permalink":"https://zrz-orz.github.io/tags/字符串/"}]},{"title":"「ZJOI2013」 K大数查询","slug":"「ZJOI2013」-K大数查询","date":"2019-09-22T02:35:41.000Z","updated":"2019-09-22T02:52:04.414Z","comments":true,"path":"2019/09/22/「ZJOI2013」-K大数查询/","link":"","permalink":"https://zrz-orz.github.io/2019/09/22/「ZJOI2013」-K大数查询/","excerpt":"这道题我们可以使用毒瘤树套树写，但是我太菜了，不想写。于是我们可以想各种离线算法，这道题我是使用的整体二分。 整体二分就是把所有询问一起二分 --Kewth 所以我们每次二分一个值，用各种数据结构快速求出每个询问的状态，那么这就是整体二分了。 整体二分只是一个小 Trick，随便 YY 一下就出来了 --CYJian","text":"这道题我们可以使用毒瘤树套树写，但是我太菜了，不想写。于是我们可以想各种离线算法，这道题我是使用的整体二分。 整体二分就是把所有询问一起二分 --Kewth 所以我们每次二分一个值，用各种数据结构快速求出每个询问的状态，那么这就是整体二分了。 整体二分只是一个小 Trick，随便 YY 一下就出来了 --CYJian 整体二分的模板类似于这样 1234567891011121314151617void solve(int l, int r, int L, int R) &#123; // l, r: 二分的区间 L, R： 当前被考虑的询问区间 if (L &gt; R) return; if (l == r) &#123; ... // 统计答案 &#125; int mid = l + r &gt;&gt; 1; for (int i = L; i &lt;= R; ++i) &#123; ... // 执行操作 &#125; ... // 还原操作 solve(l, mid, L, head); solve(mid + 1, r, head + 1, R);&#125; 对于这道题，我们每次二分一个值 $mid$ ，用线段树统计出有多少个值大于当前询问，如果当前大于 $mid$ 的数比这个询问的 $K$ 大，我们就把他放入右边区间，否则将 $K$ 减去 $mid$ 放入左区间。 细节很多。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 50005int n, m;ll ans[N];class Query &#123;public: int opt, l, r, id; ll x;&#125; q[N], lt[N], rt[N];class SegmentTree &#123;public: ll tree[N &lt;&lt; 2], tag[N &lt;&lt; 2]; void pushup(int x) &#123; tree[x] = tree[x &lt;&lt; 1] + tree[x &lt;&lt; 1 | 1]; &#125; void pushdown(int x, int l, int r) &#123; if (tag[x]) &#123; int mid = l + r &gt;&gt; 1; tree[x &lt;&lt; 1] += tag[x] * (mid - l + 1); tree[x &lt;&lt; 1 | 1] += tag[x] * (r - mid); tag[x &lt;&lt; 1] += tag[x], tag[x &lt;&lt; 1 | 1] += tag[x]; tag[x] = 0; &#125; &#125; void modify(int l, int r, int la, int ra, int val, int x) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) return tree[x] += val * (r - l + 1), tag[x] += val, void(); reg int mid = l + r &gt;&gt; 1; pushdown(x, l, r); if (la &lt;= mid) modify(l, mid, la, ra, val, x &lt;&lt; 1); if (ra &gt; mid) modify(mid + 1, r, la, ra, val, x &lt;&lt; 1 | 1); pushup(x); &#125; ll query(int l, int r, int la, int ra, int x) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) return tree[x]; reg int mid = l + r &gt;&gt; 1; pushdown(x, l, r); ll res = 0; if (la &lt;= mid) res += query(l, mid, la, ra, x &lt;&lt; 1); if (ra &gt; mid) res += query(mid + 1, r, la, ra, x &lt;&lt; 1 | 1); return res; &#125;&#125; seg;void solve(int l, int r, int L, int R) &#123; if (L &gt; R) return; if (l == r) &#123; rep (i, L, R) if (q[i].opt == 2) ans[q[i].id] = l; return; &#125; reg int mid = l + r &gt;&gt; 1, head = 0, tail = 0; rep (i, L, R) &#123; if (q[i].opt == 1) &#123; if (q[i].x &gt; mid) seg.modify(1, n, q[i].l, q[i].r, 1, 1), rt[++tail] = q[i]; else lt[++head] = q[i]; &#125; else &#123; ll cnt = seg.query(1, n, q[i].l, q[i].r, 1); if (cnt &gt;= q[i].x) rt[++tail] = q[i]; else q[i].x -= cnt, lt[++head] = q[i]; &#125; &#125; rep (i, L, R) if (q[i].opt == 1 &amp;&amp; q[i].x &gt; mid) seg.modify(1, n, q[i].l, q[i].r, -1, 1); rep (i, 1, head) q[i + L - 1] = lt[i]; rep (i, 1, tail) q[head + L + i - 1] = rt[i]; solve(l, mid, L, head + L - 1); solve(mid + 1, r, head + L, R);&#125;int main() &#123; read(n), read(m); int opt, l, r, x; int tot = 0; rep (i, 1, m) &#123; read(q[i].opt), read(q[i].l), read(q[i].r), read(q[i].x); if (q[i].opt == 2) q[i].id = ++tot; &#125; solve(-n, n, 1, m); rep (i, 1, tot) &#123; printf(\"%lld\\n\", ans[i]); &#125; return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 3332.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"整体二分","slug":"整体二分","permalink":"https://zrz-orz.github.io/tags/整体二分/"}]},{"title":"莫比乌斯反演相关记录","slug":"莫比乌斯反演相关记录","date":"2019-09-20T12:05:33.000Z","updated":"2019-09-22T02:37:07.394Z","comments":true,"path":"2019/09/20/莫比乌斯反演相关记录/","link":"","permalink":"https://zrz-orz.github.io/2019/09/20/莫比乌斯反演相关记录/","excerpt":"关于一些莫比乌斯反演的东西常用操作$$ [gcd(i,j) == 1] = \\sum_{d | gcd(i, j)} \\mu(d) $$例题yy的gcd$$ \\sum_{t \\in prime} \\sum_{i = 1}^n \\sum_{j = 1}^m [gcd(i, j) == t] $$$$ \\sum_{t \\in prime} \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} [gcd(i, j) == 1] $$","text":"关于一些莫比乌斯反演的东西常用操作$$ [gcd(i,j) == 1] = \\sum_{d | gcd(i, j)} \\mu(d) $$例题yy的gcd$$ \\sum_{t \\in prime} \\sum_{i = 1}^n \\sum_{j = 1}^m [gcd(i, j) == t] $$$$ \\sum_{t \\in prime} \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} [gcd(i, j) == 1] $$ $$ \\sum_{t \\in prime} \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} \\sum_{d | gcd(i, j)} \\mu(d) $$ $$ \\sum_{t \\in prime} \\sum_{d = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\mu(d) \\times \\lfloor\\frac{n}{dt}\\rfloor \\times \\lfloor\\frac{m}{dt}\\rfloor $$ 令 $T = td $ $$ \\sum_{T = 1}^{min(n, m)} \\lfloor\\frac{n}{T}\\rfloor \\times \\lfloor\\frac{m}{T}\\rfloor \\sum_{d | T, d \\in prime} \\mu (\\frac{T}{d}) $$ Crash的数字表格 $$ \\sum_{i = 1}^n \\sum_{j = 1}^m lcm(i, j) $$ $$ \\sum_{i = 1}^n \\sum_{j = 1}^m \\frac{ij}{gcd(i, j)} $$ $$ \\sum_{t = 1}^{min(n, m)} t\\ \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} [gcd(i, j] == 1]\\ ij $$ $$ \\sum_{t = 1}^{min(n, m)} t\\ \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} \\sum_{d | gcd(i, j)} \\mu (d) ij $$ 记 $sum(n) = \\frac{n * (n + 1)}{2}$ $$ \\sum_{t = 1}^{min(n, m)} t\\ \\sum_{d = 1}^{min(\\lfloor\\frac{n}{t}\\rfloor, \\lfloor\\frac{m}{t}\\rfloor)} d^2 \\mu(d) \\times sum(\\lfloor\\frac{n}{td}\\rfloor) \\times sum(\\lfloor\\frac{m}{td}\\rfloor) $$ 记 $ f(n, m) = \\sum_{d = 1}^{min(n, m)} d^2 \\mu(d) \\times sum(\\lfloor\\frac{n}{d}\\rfloor) \\times sum(\\lfloor\\frac{m}{d}\\rfloor) $ $$ \\sum_{t = 1}^{min(n, m)} t \\times f(\\lfloor\\frac{n}{t}\\rfloor, \\lfloor\\frac{m}{t}\\rfloor) $$","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://zrz-orz.github.io/tags/数论/"}]},{"title":"hello world","slug":"hello-world","date":"2019-09-20T08:37:21.000Z","updated":"2019-09-21T06:23:07.464Z","comments":true,"path":"2019/09/20/hello-world/","link":"","permalink":"https://zrz-orz.github.io/2019/09/20/hello-world/","excerpt":"","text":"Hello, Hexo Hello, Hexo 12345#include &lt;bits/stdc++.h&gt;int main() &#123; puts(\"Hello, Hexo\"); return 0;&#125;","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://zrz-orz.github.io/tags/杂项/"}]}]}