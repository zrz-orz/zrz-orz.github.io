{"meta":{"title":"zrz_orz's Blog","subtitle":null,"description":null,"author":"zrz_orz","url":"https://zrz-orz.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-09-21T06:55:52.000Z","updated":"2019-09-21T06:55:52.494Z","comments":true,"path":"categories/index.html","permalink":"https://zrz-orz.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-21T06:55:31.000Z","updated":"2019-09-21T06:55:31.901Z","comments":true,"path":"tags/index.html","permalink":"https://zrz-orz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"「Luogu 2787」 语文1(chin1)-理理思维","slug":"「Luogu-2787」-语文1-chin1-理理思维","date":"2019-09-22T04:00:42.000Z","updated":"2019-09-22T04:05:42.311Z","comments":true,"path":"2019/09/22/「Luogu-2787」-语文1-chin1-理理思维/","link":"","permalink":"https://zrz-orz.github.io/2019/09/22/「Luogu-2787」-语文1-chin1-理理思维/","excerpt":"","text":"听说这是珂朵莉树的板子，但是我不会 开 $26$ 棵线段树，线段树要支持区间赋值，区间求和。 之后的就暴力更新。 毒瘤题面，在最后说大小写不敏感。。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 50005int n, m;char s[N];class SegmentTree &#123;public: int tree[N &lt;&lt; 2], tag[N &lt;&lt; 2]; SegmentTree() &#123; memset(tag, -1, sizeof tag); &#125; void pushup(int x) &#123; tree[x] = tree[x &lt;&lt; 1] + tree[x &lt;&lt; 1 | 1]; &#125; void pushdown(int x, int l, int r) &#123; if (tag[x] != -1) &#123; int mid = l + r &gt;&gt; 1; tree[x &lt;&lt; 1] = tag[x] * (mid - l + 1), tree[x &lt;&lt; 1 | 1] = tag[x] * (r - mid); tag[x &lt;&lt; 1] = tag[x], tag[x &lt;&lt; 1 | 1] = tag[x]; tag[x] = -1; &#125; &#125; void modify(int l, int r, int la, int ra, int x, int val) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) &#123; tree[x] = val * (r - l + 1); tag[x] = val; return; &#125; reg int mid = l + r &gt;&gt; 1; pushdown(x, l, r); if (la &lt;= mid) modify(l, mid, la, ra, x &lt;&lt; 1, val); if (ra &gt; mid) modify(mid + 1, r, la, ra, x &lt;&lt; 1 | 1, val); pushup(x); &#125; int query(int l, int r, int la, int ra, int x) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) return tree[x]; reg int mid = l + r &gt;&gt; 1; int res = 0; pushdown(x, l, r); if (la &lt;= mid) res += query(l, mid, la, ra, x &lt;&lt; 1); if (ra &gt; mid) res += query(mid + 1, r, la, ra, x &lt;&lt; 1 | 1); return res; &#125; &#125; seg[26];inline void Modify(int l, int r, int id) &#123; rep (i, 0, 25) &#123; seg[i].modify(1, n, l, r, 1, 0); &#125; seg[id].modify(1, n, l, r, 1, 1);&#125;inline void Sort(int l, int r) &#123; int tmp[30]; memset(tmp, 0, sizeof tmp); rep (i, 0, 25) tmp[i] = seg[i].query(1, n, l, r, 1); rep (i, 0, 25) seg[i].modify(1, n, l, r, 1, 0); int pos = l; rep (i, 0, 25) &#123; int nx = pos + tmp[i] - 1; if (nx &lt; pos) continue; seg[i].modify(1, n, pos, nx, 1, 1); pos = nx + 1; &#125;&#125;int main() &#123; read(n), read(m); scanf (\"%s\", s + 1); rep (i, 1, n) &#123; if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') s[i] = s[i] - 'a' + 'A'; seg[s[i] - 'A'].modify(1, n, i, i, 1, 1); &#125; int opt, l, r; char str[4]; while(m--) &#123; read(opt), read(l), read(r); switch(opt) &#123; case 1 : scanf (\"%s\", str); if (str[0] &gt;= 'a' &amp;&amp; str[0] &lt;= 'z') str[0] = str[0] - 'a' + 'A'; printf(\"%d\\n\", seg[str[0] - 'A'].query(1, n, l, r, 1)); break; case 2 : scanf (\"%s\", str); if (str[0] &gt;= 'a' &amp;&amp; str[0] &lt;= 'z') str[0] = str[0] - 'a' + 'A'; Modify(l, r, str[0] - 'A'); break; case 3 : Sort(l, r); break; &#125; &#125; return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 2787.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zrz-orz.github.io/tags/数据结构/"},{"name":"字符串","slug":"字符串","permalink":"https://zrz-orz.github.io/tags/字符串/"}]},{"title":"「ZJOI2013」 K大数查询","slug":"「ZJOI2013」-K大数查询","date":"2019-09-22T02:35:41.000Z","updated":"2019-09-22T02:52:04.414Z","comments":true,"path":"2019/09/22/「ZJOI2013」-K大数查询/","link":"","permalink":"https://zrz-orz.github.io/2019/09/22/「ZJOI2013」-K大数查询/","excerpt":"这道题我们可以使用毒瘤树套树写，但是我太菜了，不想写。于是我们可以想各种离线算法，这道题我是使用的整体二分。 整体二分就是把所有询问一起二分 --Kewth 所以我们每次二分一个值，用各种数据结构快速求出每个询问的状态，那么这就是整体二分了。 整体二分只是一个小 Trick，随便 YY 一下就出来了 --CYJian","text":"这道题我们可以使用毒瘤树套树写，但是我太菜了，不想写。于是我们可以想各种离线算法，这道题我是使用的整体二分。 整体二分就是把所有询问一起二分 --Kewth 所以我们每次二分一个值，用各种数据结构快速求出每个询问的状态，那么这就是整体二分了。 整体二分只是一个小 Trick，随便 YY 一下就出来了 --CYJian 整体二分的模板类似于这样 1234567891011121314151617void solve(int l, int r, int L, int R) &#123; // l, r: 二分的区间 L, R： 当前被考虑的询问区间 if (L &gt; R) return; if (l == r) &#123; ... // 统计答案 &#125; int mid = l + r &gt;&gt; 1; for (int i = L; i &lt;= R; ++i) &#123; ... // 执行操作 &#125; ... // 还原操作 solve(l, mid, L, head); solve(mid + 1, r, head + 1, R);&#125; 对于这道题，我们每次二分一个值 $mid$ ，用线段树统计出有多少个值大于当前询问，如果当前大于 $mid$ 的数比这个询问的 $K$ 大，我们就把他放入右边区间，否则将 $K$ 减去 $mid$ 放入左区间。 细节很多。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;// Defination &#123;&#123;&#123;#define PI std::pair&lt;int, int&gt;#define mk std::make_pair#define reg register#define ll long long#define rep(i, a, b) for(reg int i = a; i &lt;= b; ++i)#define per(i, a, b) for(reg int i = a; i &gt;= b; --i)#define pb push_back#define debug(...) fprintf(stderr, __VA_ARGS__)// &#125;&#125;&#125;template&lt;typename T&gt; T max(T a, T b) &#123; return a &gt; b ? a : b; &#125;template&lt;typename T&gt; T min(T a, T b) &#123; return a &lt; b ? a : b; &#125;template&lt;typename T&gt; void read(T &amp;x) &#123; x = 0; reg char ch = getchar(); reg int f = 1; for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1; for (; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); x *= f;&#125;#define N 50005int n, m;ll ans[N];class Query &#123;public: int opt, l, r, id; ll x;&#125; q[N], lt[N], rt[N];class SegmentTree &#123;public: ll tree[N &lt;&lt; 2], tag[N &lt;&lt; 2]; void pushup(int x) &#123; tree[x] = tree[x &lt;&lt; 1] + tree[x &lt;&lt; 1 | 1]; &#125; void pushdown(int x, int l, int r) &#123; if (tag[x]) &#123; int mid = l + r &gt;&gt; 1; tree[x &lt;&lt; 1] += tag[x] * (mid - l + 1); tree[x &lt;&lt; 1 | 1] += tag[x] * (r - mid); tag[x &lt;&lt; 1] += tag[x], tag[x &lt;&lt; 1 | 1] += tag[x]; tag[x] = 0; &#125; &#125; void modify(int l, int r, int la, int ra, int val, int x) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) return tree[x] += val * (r - l + 1), tag[x] += val, void(); reg int mid = l + r &gt;&gt; 1; pushdown(x, l, r); if (la &lt;= mid) modify(l, mid, la, ra, val, x &lt;&lt; 1); if (ra &gt; mid) modify(mid + 1, r, la, ra, val, x &lt;&lt; 1 | 1); pushup(x); &#125; ll query(int l, int r, int la, int ra, int x) &#123; if (l &gt;= la &amp;&amp; r &lt;= ra) return tree[x]; reg int mid = l + r &gt;&gt; 1; pushdown(x, l, r); ll res = 0; if (la &lt;= mid) res += query(l, mid, la, ra, x &lt;&lt; 1); if (ra &gt; mid) res += query(mid + 1, r, la, ra, x &lt;&lt; 1 | 1); return res; &#125;&#125; seg;void solve(int l, int r, int L, int R) &#123; if (L &gt; R) return; if (l == r) &#123; rep (i, L, R) if (q[i].opt == 2) ans[q[i].id] = l; return; &#125; reg int mid = l + r &gt;&gt; 1, head = 0, tail = 0; rep (i, L, R) &#123; if (q[i].opt == 1) &#123; if (q[i].x &gt; mid) seg.modify(1, n, q[i].l, q[i].r, 1, 1), rt[++tail] = q[i]; else lt[++head] = q[i]; &#125; else &#123; ll cnt = seg.query(1, n, q[i].l, q[i].r, 1); if (cnt &gt;= q[i].x) rt[++tail] = q[i]; else q[i].x -= cnt, lt[++head] = q[i]; &#125; &#125; rep (i, L, R) if (q[i].opt == 1 &amp;&amp; q[i].x &gt; mid) seg.modify(1, n, q[i].l, q[i].r, -1, 1); rep (i, 1, head) q[i + L - 1] = lt[i]; rep (i, 1, tail) q[head + L + i - 1] = rt[i]; solve(l, mid, L, head + L - 1); solve(mid + 1, r, head + L, R);&#125;int main() &#123; read(n), read(m); int opt, l, r, x; int tot = 0; rep (i, 1, m) &#123; read(q[i].opt), read(q[i].l), read(q[i].r), read(q[i].x); if (q[i].opt == 2) q[i].id = ++tot; &#125; solve(-n, n, 1, m); rep (i, 1, tot) &#123; printf(\"%lld\\n\", ans[i]); &#125; return 0; &#125;/* _____ ____ _____|__ / | _ \\ |__ / / / | |_) | / / / /_ | _ &lt; / /_ /____| |_| \\_\\ /____| ________________________________________ &lt; 3332.cpp is created by zrz who is weak &gt; ---------------------------------------- \\ ^__^ \\ (^^)\\_______ (__)\\ )\\/\\ U ||----w | || ||*/","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"整体二分","slug":"整体二分","permalink":"https://zrz-orz.github.io/tags/整体二分/"}]},{"title":"莫比乌斯反演相关记录","slug":"莫比乌斯反演相关记录","date":"2019-09-20T12:05:33.000Z","updated":"2019-09-22T02:37:07.394Z","comments":true,"path":"2019/09/20/莫比乌斯反演相关记录/","link":"","permalink":"https://zrz-orz.github.io/2019/09/20/莫比乌斯反演相关记录/","excerpt":"关于一些莫比乌斯反演的东西常用操作$$ [gcd(i,j) == 1] = \\sum_{d | gcd(i, j)} \\mu(d) $$例题yy的gcd$$ \\sum_{t \\in prime} \\sum_{i = 1}^n \\sum_{j = 1}^m [gcd(i, j) == t] $$$$ \\sum_{t \\in prime} \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} [gcd(i, j) == 1] $$","text":"关于一些莫比乌斯反演的东西常用操作$$ [gcd(i,j) == 1] = \\sum_{d | gcd(i, j)} \\mu(d) $$例题yy的gcd$$ \\sum_{t \\in prime} \\sum_{i = 1}^n \\sum_{j = 1}^m [gcd(i, j) == t] $$$$ \\sum_{t \\in prime} \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} [gcd(i, j) == 1] $$ $$ \\sum_{t \\in prime} \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} \\sum_{d | gcd(i, j)} \\mu(d) $$ $$ \\sum_{t \\in prime} \\sum_{d = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\mu(d) \\times \\lfloor\\frac{n}{dt}\\rfloor \\times \\lfloor\\frac{m}{dt}\\rfloor $$ 令 $T = td $ $$ \\sum_{T = 1}^{min(n, m)} \\lfloor\\frac{n}{T}\\rfloor \\times \\lfloor\\frac{m}{T}\\rfloor \\sum_{d | T, d \\in prime} \\mu (\\frac{T}{d}) $$ Crash的数字表格 $$ \\sum_{i = 1}^n \\sum_{j = 1}^m lcm(i, j) $$ $$ \\sum_{i = 1}^n \\sum_{j = 1}^m \\frac{ij}{gcd(i, j)} $$ $$ \\sum_{t = 1}^{min(n, m)} t\\ \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} [gcd(i, j] == 1]\\ ij $$ $$ \\sum_{t = 1}^{min(n, m)} t\\ \\sum_{i = 1}^{\\lfloor\\frac{n}{t}\\rfloor} \\sum_{j = 1}^{\\lfloor\\frac{m}{t}\\rfloor} \\sum_{d | gcd(i, j)} \\mu (d) ij $$ 记 $sum(n) = \\frac{n * (n + 1)}{2}$ $$ \\sum_{t = 1}^{min(n, m)} t\\ \\sum_{d = 1}^{min(\\lfloor\\frac{n}{t}\\rfloor, \\lfloor\\frac{m}{t}\\rfloor)} d^2 \\mu(d) \\times sum(\\lfloor\\frac{n}{td}\\rfloor) \\times sum(\\lfloor\\frac{m}{td}\\rfloor) $$ 记 $ f(n, m) = \\sum_{d = 1}^{min(n, m)} d^2 \\mu(d) \\times sum(\\lfloor\\frac{n}{d}\\rfloor) \\times sum(\\lfloor\\frac{m}{d}\\rfloor) $ $$ \\sum_{t = 1}^{min(n, m)} t \\times f(\\lfloor\\frac{n}{t}\\rfloor, \\lfloor\\frac{m}{t}\\rfloor) $$","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://zrz-orz.github.io/tags/OI/"},{"name":"数论","slug":"数论","permalink":"https://zrz-orz.github.io/tags/数论/"}]},{"title":"hello world","slug":"hello-world","date":"2019-09-20T08:37:21.000Z","updated":"2019-09-21T06:23:07.464Z","comments":true,"path":"2019/09/20/hello-world/","link":"","permalink":"https://zrz-orz.github.io/2019/09/20/hello-world/","excerpt":"","text":"Hello, Hexo Hello, Hexo 12345#include &lt;bits/stdc++.h&gt;int main() &#123; puts(\"Hello, Hexo\"); return 0;&#125;","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"https://zrz-orz.github.io/tags/杂项/"}]}]}